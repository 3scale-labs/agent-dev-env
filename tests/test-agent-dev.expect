#!/usr/bin/expect -f
#
# Integration Test Suite for agent-dev
# =====================================
#
# This test suite verifies the agent-dev sandbox environment works correctly:
#   - Overlay filesystem isolation (files don't leak to real repo)
#   - Protected directories (.git) are read-only
#   - Home directory is isolated
#   - Merge workflow handles NEW/MODIFIED/DELETED files
#
# Run from repository root: ./tests/test-agent-dev.expect
#

# ==============================================================================
# Configuration
# ==============================================================================

set timeout 30

# Disable output buffering
log_user 1

# Test environment paths
set repo_dir [pwd]
set test_ai_home "/tmp/agent-dev-test-aihome-[clock seconds]"
set overlay_base "$test_ai_home/.overlay[exec realpath $repo_dir]"
set overlay_upper "$overlay_base/upper"

# Export AI_HOME for spawned processes
set env(AI_HOME) $test_ai_home

# ==============================================================================
# Output Helpers
# ==============================================================================

# ANSI colors
set GREEN "\033\[0;32m"
set RED "\033\[0;31m"
set YELLOW "\033\[0;33m"
set BOLD "\033\[1m"
set NC "\033\[0m"

# Test counters
set tests_passed 0
set tests_failed 0

proc pass {msg} {
    global GREEN NC tests_passed
    puts "  ${GREEN}PASS${NC} $msg"
    incr tests_passed
}

proc fail {msg} {
    global RED NC tests_failed
    puts "  ${RED}FAIL${NC} $msg"
    incr tests_failed
}

proc info {msg} {
    global YELLOW NC
    puts "  ${YELLOW}INFO${NC} $msg"
}

proc section {title} {
    global BOLD NC
    puts "\n${BOLD}$title${NC}"
    puts [string repeat "-" [string length $title]]
}

# ==============================================================================
# Test Utilities
# ==============================================================================

# Waits for process to exit and consumes remaining output
proc finish_process {} {
    global spawn_id
    expect {
        eof { }
        timeout {
            fail "Timeout waiting for process to exit"
            catch { close -i $spawn_id }
        }
    }
    catch { wait -i $spawn_id }
}

# Runs a command in agent-dev and returns spawn_id
proc run_in_sandbox {cmd} {
    global spawn_id
    spawn ./agent-dev bash -c $cmd
    return $spawn_id
}

# Expects merge-overlay to report no changes (or auto-discard ignored files), then finishes
proc expect_no_changes {} {
    global spawn_id
    expect {
        "No changes in overlay" { }
        "Auto-discarded" {
            # Ignored files were auto-discarded, wait for completion
            expect {
                "No changes in overlay" { }
                eof { }
                timeout { fail "Timeout after auto-discard" }
            }
        }
        eof { }
        timeout {
            fail "Timeout waiting for completion"
            # Kill the process to avoid hanging
            catch { close -i $spawn_id }
        }
    }
    catch { wait -i $spawn_id }
}

# Cleans overlay directory for fresh test
proc reset_overlay {} {
    global overlay_upper
    catch { exec rm -rf $overlay_upper }
    catch { exec mkdir -p $overlay_upper }
}

# Checks if file exists in repository
proc file_in_repo {filename} {
    global repo_dir
    return [file exists "$repo_dir/$filename"]
}

# Checks if file exists in overlay
proc file_in_overlay {filename} {
    global overlay_upper
    return [file exists "$overlay_upper/$filename"]
}

# ==============================================================================
# Setup and Teardown
# ==============================================================================

proc setup {} {
    global test_ai_home repo_dir

    section "Setup"

    # Verify we're in a git repo with agent-dev available
    if {![file exists "$repo_dir/.git"]} {
        puts "ERROR: Must run from git repository root"
        exit 1
    }
    if {![file executable "./agent-dev"]} {
        puts "ERROR: ./agent-dev not found or not executable"
        exit 1
    }

    # Create isolated test environment
    exec mkdir -p $test_ai_home
    info "Created test AI_HOME at $test_ai_home"
}

proc teardown {} {
    global test_ai_home

    section "Teardown"
    exec rm -rf $test_ai_home
    info "Cleaned up test environment"
}

# ==============================================================================
# Test: Sandbox Initialization
# ==============================================================================

proc test_sandbox_starts_correctly {} {
    global overlay_upper spawn_id

    section "Test: Sandbox Initialization"

    reset_overlay
    run_in_sandbox "pwd"

    # Should display isolation banner (after npm update check)
    expect {
        -re "Starting Claude Code" {
            pass "Displays isolation banner"
        }
        timeout {
            fail "No isolation banner displayed"
            finish_process
            return
        }
    }

    # Should show overlay information
    expect {
        "Overlay directories:" {
            pass "Shows overlay directory info"
        }
        timeout {
            fail "Missing overlay directory info"
            finish_process
            return
        }
    }

    # Wait for command to complete and merge-overlay to run
    expect {
        -re "No changes in overlay|Auto-discarded" {
            pass "Empty overlay handled correctly"
        }
        eof { }
        timeout {
            fail "Timeout waiting for completion"
        }
    }

    catch wait
}

# ==============================================================================
# Test: File Isolation
# ==============================================================================

proc test_files_stay_in_overlay {} {
    global repo_dir overlay_upper spawn_id

    section "Test: File Isolation"

    set testfile "isolation-test-[clock seconds].txt"

    run_in_sandbox "echo 'test content' > $testfile && cat $testfile"

    expect {
        "test content" {
            pass "File created and readable in sandbox"
        }
        timeout {
            fail "Could not create/read file in sandbox"
            finish_process
            return
        }
    }

    # Discard the test file when merge-overlay prompts
    expect {
        -re "NEW.*$testfile" {
            send "r\r"
            expect "Discarded" { pass "File discarded via merge-overlay" }
        }
        "No changes" { info "No merge prompt (unexpected)" }
        eof { }
        timeout { fail "Timeout waiting for merge prompt" }
    }

    catch wait

    # Verify file didn't leak to real repo
    if {![file_in_repo $testfile]} {
        pass "File did not leak to repository"
    } else {
        fail "File leaked to repository!"
        exec rm -f "$repo_dir/$testfile"
    }
}

# ==============================================================================
# Test: Protected Directories
# ==============================================================================

proc test_git_directory_protected {} {
    global repo_dir spawn_id

    section "Test: Protected Directories"

    run_in_sandbox "echo '# test' >> .git/config 2>&1; echo EXIT_CODE:\$?"

    expect {
        -re "EXIT_CODE:(1|2)" {
            pass "Write to .git/config blocked"
        }
        "EXIT_CODE:0" {
            fail "Write to .git/config succeeded (should be blocked)"
        }
        timeout {
            fail "Timeout testing .git protection"
            finish_process
            return
        }
    }

    expect_no_changes

    # Double-check .git/config wasn't modified
    if {[catch {exec grep -c "# test" "$repo_dir/.git/config"} result] || $result eq "0"} {
        pass ".git/config remains unmodified"
    } else {
        fail ".git/config was modified!"
    }
}

# ==============================================================================
# Test: Home Directory Isolation
# ==============================================================================

proc test_home_directory_isolated {} {
    global test_ai_home spawn_id

    section "Test: Home Directory Isolation"

    set testfile "test-home-[clock seconds].txt"

    run_in_sandbox "touch ~/$testfile && ls ~/$testfile"

    expect {
        $testfile {
            pass "Can create files in sandbox home"
        }
        timeout {
            fail "Could not create file in sandbox home"
            finish_process
            return
        }
    }

    expect_no_changes

    # Verify file is in test AI_HOME, not real home
    if {[file exists "$test_ai_home/$testfile"]} {
        pass "File created in isolated AI_HOME"
        exec rm -f "$test_ai_home/$testfile"
    } else {
        fail "File not found in isolated AI_HOME"
    }

    if {![file exists "$::env(HOME)/$testfile"]} {
        pass "Real home directory unchanged"
    } else {
        fail "File leaked to real home directory!"
        exec rm -f "$::env(HOME)/$testfile"
    }
}

# ==============================================================================
# Test: Working Directory
# ==============================================================================

proc test_working_directory_preserved {} {
    global repo_dir spawn_id

    section "Test: Working Directory"

    run_in_sandbox "pwd"

    expect {
        $repo_dir {
            pass "Working directory matches repository"
        }
        timeout {
            fail "Working directory not set correctly"
            finish_process
            return
        }
    }

    expect_no_changes
}

# ==============================================================================
# Test: Network Access
# ==============================================================================

proc test_network_available {} {
    global spawn_id

    section "Test: Network Access"

    run_in_sandbox "ping -c 1 -W 2 8.8.8.8 >/dev/null 2>&1 && echo NETWORK_OK || echo NETWORK_FAIL"

    expect {
        "NETWORK_OK" {
            pass "Network is accessible"
        }
        "NETWORK_FAIL" {
            info "Network unavailable (may be expected)"
        }
        timeout {
            fail "Timeout testing network"
            finish_process
            return
        }
    }

    expect_no_changes
}

# ==============================================================================
# Test: Multi-file Merge Workflow
# ==============================================================================

proc test_merge_workflow {} {
    global repo_dir overlay_upper spawn_id

    section "Test: Merge Workflow (NEW/MODIFIED/DELETED)"

    set ts [clock seconds]

    # Create files in repo that we'll modify and delete
    set file_to_modify "modify-me-$ts.txt"
    set file_to_delete "delete-me-$ts.txt"
    exec sh -c "echo 'original' > $repo_dir/$file_to_modify"
    exec sh -c "echo 'will be deleted' > $repo_dir/$file_to_delete"

    # In sandbox: create 3 new files, modify 1, delete 1
    set new_accept "new-accept-$ts.txt"
    set new_skip "new-skip-$ts.txt"
    set new_discard "new-discard-$ts.txt"

    run_in_sandbox "
        echo 'new file 1' > $new_accept
        echo 'new file 2' > $new_skip
        echo 'new file 3' > $new_discard
        echo 'modified content' > $file_to_modify
        rm $file_to_delete
        echo 'CHANGES_COMPLETE'
    "

    expect {
        "CHANGES_COMPLETE" {
            pass "Created 3 new, 1 modified, 1 deleted"
        }
        timeout {
            fail "Timeout creating changes"
            finish_process
            return
        }
    }

    # Handle merge-overlay prompts
    # We'll: accept file1, skip file2, discard file3, accept modified, accept deleted
    set done 0
    while {!$done} {
        expect {
            -re "NEW.*$new_accept.*Action" {
                send "y\r"
                info "Accepting: $new_accept"
            }
            -re "NEW.*$new_skip.*Action" {
                send "n\r"
                info "Skipping: $new_skip"
            }
            -re "NEW.*$new_discard.*Action" {
                send "r\r"
                info "Discarding: $new_discard"
            }
            -re "MODIFIED.*$file_to_modify.*Action" {
                send "y\r"
                info "Accepting modification: $file_to_modify"
            }
            -re "DELETED.*$file_to_delete.*Action" {
                send "y\r"
                info "Accepting deletion: $file_to_delete"
            }
            -re "Action.*\\?" {
                # Catch-all for unexpected prompts
                send "n\r"
                info "Skipping unexpected prompt"
            }
            eof {
                set done 1
            }
            timeout {
                fail "Timeout during merge workflow"
                set done 1
            }
        }
    }

    catch wait

    # Verify results
    info "Verifying merge results..."

    # Accepted new file should be in repo
    if {[file_in_repo $new_accept]} {
        pass "Accepted file is in repository"
    } else {
        fail "Accepted file not found in repository"
    }

    # Skipped file should remain in overlay
    if {[file_in_overlay $new_skip]} {
        pass "Skipped file remains in overlay"
    } else {
        fail "Skipped file not in overlay"
    }

    # Discarded file should be nowhere
    if {![file_in_repo $new_discard] && ![file_in_overlay $new_discard]} {
        pass "Discarded file removed completely"
    } else {
        fail "Discarded file still exists"
    }

    # Modified file should have new content
    if {[file_in_repo $file_to_modify]} {
        set content [exec cat "$repo_dir/$file_to_modify"]
        if {$content eq "modified content"} {
            pass "Modified file has new content"
        } else {
            fail "Modified file has wrong content: $content"
        }
    } else {
        fail "Modified file missing from repo"
    }

    # Deleted file should be gone
    if {![file_in_repo $file_to_delete]} {
        pass "Deleted file removed from repository"
    } else {
        fail "Deleted file still in repository"
    }

    # Cleanup
    catch { exec rm -f "$repo_dir/$new_accept" }
    catch { exec rm -f "$repo_dir/$file_to_modify" }
    catch { exec rm -rf "$overlay_upper/$new_skip" }
}

# ==============================================================================
# Test: Empty Overlay
# ==============================================================================

proc test_empty_overlay_handled {} {
    global spawn_id

    section "Test: Empty Overlay Handling"

    reset_overlay

    run_in_sandbox "echo 'no changes here'"

    expect {
        "no changes here" {
            pass "Command executed successfully"
        }
        timeout {
            fail "Timeout running command"
            finish_process
            return
        }
    }

    expect {
        "No changes in overlay" {
            pass "Empty overlay detected correctly"
        }
        eof { }
        timeout {
            fail "Timeout waiting for empty overlay message"
        }
    }

    catch wait
}

# ==============================================================================
# Main
# ==============================================================================

proc run_tests {} {
    global tests_passed tests_failed GREEN RED NC BOLD

    puts "\n${BOLD}========================================"
    puts "  agent-dev Integration Test Suite"
    puts "========================================${NC}\n"

    setup

    # Run all tests
    test_sandbox_starts_correctly
    test_files_stay_in_overlay
    test_git_directory_protected
    test_home_directory_isolated
    test_working_directory_preserved
    test_network_available
    test_merge_workflow
    test_empty_overlay_handled

    teardown

    # Print summary
    set total [expr $tests_passed + $tests_failed]
    puts "\n${BOLD}========================================"
    puts "  Results"
    puts "========================================${NC}"
    puts ""
    puts "  Total: $total assertions"
    puts "  ${GREEN}Passed: $tests_passed${NC}"
    puts "  ${RED}Failed: $tests_failed${NC}"
    puts ""

    if {$tests_failed > 0} {
        puts "${RED}Some tests failed!${NC}"
        exit 1
    } else {
        puts "${GREEN}All tests passed!${NC}"
        exit 0
    }
}

run_tests
